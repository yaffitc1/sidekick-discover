#!/usr/bin/env python3
"""Validate HTML output from dashboard.py render_dashboard function.

This script validates that the generated HTML is well-formed and has no syntax errors.
"""

import sys
import tempfile
from pathlib import Path
import html.parser


class HTMLValidator(html.parser.HTMLParser):
    """HTML parser that validates structure and reports errors."""
    
    def __init__(self):
        super().__init__()
        self.errors = []
        self.warnings = []
        self.tag_stack = []
        self.total_tags = 0
        
    def handle_startendtag(self, tag, attrs):
        """Handle self-closing tags like <meta />, <br />, etc."""
        self.total_tags += 1
        # Self-closing tags don't need to be tracked in tag_stack
    
    def handle_starttag(self, tag, attrs):
        self.tag_stack.append(tag)
        self.total_tags += 1
        
        # Self-closing tags don't need closing (but handle_startendtag handles them)
        self_closing_tags = {'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 
                            'input', 'link', 'meta', 'param', 'source', 'track', 'wbr'}
        if tag.lower() in self_closing_tags:
            # Remove from stack since it's self-closing
            if self.tag_stack and self.tag_stack[-1] == tag:
                self.tag_stack.pop()
    
    def handle_endtag(self, tag):
        if not self.tag_stack:
            self.errors.append(f"Closing tag </{tag}> without opening tag")
        elif self.tag_stack[-1] != tag:
            # Check if tag is somewhere in the stack (might be nested)
            if tag in self.tag_stack:
                while self.tag_stack and self.tag_stack[-1] != tag:
                    popped = self.tag_stack.pop()
                    self.warnings.append(f"Tag </{popped}> closed implicitly before </{tag}>")
            else:
                self.errors.append(f"Mismatched tags: expected </{self.tag_stack[-1]}>, got </{tag}>")
        
        if self.tag_stack and self.tag_stack[-1] == tag:
            self.tag_stack.pop()
    
    def error(self, message):
        self.errors.append(f"Parser error: {message}")
    
    def get_summary(self):
        """Get validation summary."""
        return {
            'errors': self.errors,
            'warnings': self.warnings,
            'unclosed_tags': self.tag_stack.copy(),
            'total_tags': self.total_tags,
        }


def validate_dashboard_html():
    """Validate HTML generated by render_dashboard function."""
    try:
        # Import here to avoid import errors if discovery package isn't installed
        sys.path.insert(0, str(Path(__file__).parent.parent))
        from discovery.render.dashboard import render_dashboard
        
        # Create a temporary file for HTML output
        with tempfile.NamedTemporaryFile(mode='w', suffix='.html', delete=False) as f:
            temp_path = f.name
        
        try:
            # Call render_dashboard with minimal sample data
            render_dashboard(
                source_name="test_validation",
                profiles={
                    "col1": {"nullPct": 0.1, "dtype": "int64"},
                    "col2": {"nullPct": 0.0, "dtype": "object", "topK": [{"value": "A", "count": 10}]}
                },
                tests={"pearson": {"col1": {"col2": 0.5}}},
                insights=[
                    {"id": "test1", "title": "Test insight", "score": 80, "severity": "high"}
                ],
                out_html=temp_path,
                relationships=[
                    {
                        "source_table": "table1",
                        "source_column": "col1",
                        "target_table": "table2",
                        "target_column": "col2",
                        "match_rate": 0.95,
                        "confidence": "high",
                        "type": "foreign_key"
                    }
                ],
                relationship_graph={
                    "nodes": [{"id": "table1", "label": "table1"}],
                    "edges": []
                },
                validation_checks=[
                    {
                        "column": "col1",
                        "type": "completeness",
                        "severity": "medium",
                        "message": "Test validation check"
                    }
                ],
                kpi_suggestions=[
                    {
                        "kpi_type": "sum",
                        "formula": "SUM(col1)",
                        "description": "Total col1",
                        "relevance_score": 0.8
                    }
                ],
                tasks={
                    "tasks": {
                        "data_quality": [
                            {
                                "id": "task1",
                                "title": "Test task",
                                "priority": "high",
                                "actions": ["Action 1", "Action 2"]
                            }
                        ]
                    },
                    "summary": {"total_tasks": 1}
                },
                overview_stats={
                    "total_tables": 2,
                    "total_columns": 5,
                    "total_issues": 3
                },
            )
            
            # Read the generated HTML
            with open(temp_path, 'r', encoding='utf-8') as f:
                html_content = f.read()
            
            # Validate HTML
            validator = HTMLValidator()
            validator.feed(html_content)
            
            # Check for unclosed tags
            if validator.tag_stack:
                validator.errors.append(
                    f"Unclosed tags: {', '.join(validator.tag_stack)}"
                )
            
            summary = validator.get_summary()
            
            # Print results
            if summary['errors']:
                print("❌ HTML Validation FAILED")
                print(f"\nFound {len(summary['errors'])} error(s):")
                for error in summary['errors']:
                    print(f"  • {error}")
                return False
            else:
                print("✅ HTML Validation PASSED")
                print(f"\nValidation Summary:")
                print(f"  • Total tags processed: {summary['total_tags']}")
                print(f"  • HTML length: {len(html_content):,} characters")
                if summary['warnings']:
                    print(f"  • Warnings: {len(summary['warnings'])}")
                    for warning in summary['warnings'][:5]:  # Show first 5 warnings
                        print(f"    - {warning}")
                return True
                
        finally:
            # Clean up
            Path(temp_path).unlink()
            
    except Exception as e:
        print(f"❌ Error during validation: {e}")
        import traceback
        traceback.print_exc()
        return False


if __name__ == "__main__":
    success = validate_dashboard_html()
    sys.exit(0 if success else 1)

